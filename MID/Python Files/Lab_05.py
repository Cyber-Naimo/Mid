# -*- coding: utf-8 -*-
"""AILAB05B_search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mD_Tmun0fX0ZKWsbQdzup2GxxQwNUcTi

**STACK IMPLEMENTATION**
"""

# Python program to
# demonstrate stack implementation
# using list

stack = []

# append() function to push
# element in the stack
stack.append('a')
stack.append('b')
stack.append('c')

print('Initial stack')
print(stack)

# pop() function to pop
# element from stack in
# LIFO order
print('\nElements popped from stack:')
print(stack.pop())
print(stack.pop())
print(stack.pop())

print('\nStack after elements are popped:')
print(stack)

"""A TreeNode is a data structure that represents one entry of a tree, which is composed of multiple of such nodes.

The topmost node of a tree is called the “root”, and each node (with the exception of the root node) is associated with one parent node. Likewise, each node can have an arbitrary(random) number of child nodes.This is in contrast to binary trees, which are restricted to having at most two children per node (left child and right child).
 An implementation of a TreeNode class in Python should have functions to add nodes, remove nodes, and traverse nodes within the tree.
"""

class TreeNode:
  def __init__(self, value):
    self.value = value # data
    self.children = [] # references to other nodes

  def add_child(self, child_node):
    # creates parent-child relationship
    print("Adding " + child_node.value)
    self.children.append(child_node)

  def remove_child(self, child_node):
    # removes parent-child relationship
    print("Removing " + child_node.value + " from " + self.value)
    self.children = [child for child in self.children
                     if child is not child_node]

  def traverse(self):
    # moves through each node referenced from self downwards
    nodes_to_visit = [self]
    while len(nodes_to_visit) > 0:
      current_node = nodes_to_visit.pop()
      print(current_node.value)
      nodes_to_visit += current_node.children

"""**Explanation:**

The __init__ method initializes a new TreeNode with a value and an empty list of children.
The add_child method adds a new child node to the current node's children list, printing a message for clarity.
The remove_child method removes a child node from the current node's children list, filtering out the matching node and printing a message.
The traverse method performs a pre-order traversal (visiting the root node first, then its children recursively). It uses a stack (implemented as nodes_to_visit) to keep track of nodes to visit. Here, pop(0) ensures pre-order traversal by processing nodes from the beginning of the list.
TreeNode class, using nodes_to_visit = [self]  create a stack dynamically
n the traverse method, the line nodes_to_visit = [self] creates a new list and adds the current TreeNode (represented by self) as the first element.
This list essentially acts as a stack because the elements are processed in the order they were added:
self is added first.
When nodes_to_visit is not empty, the code retrieves the element using current_node = nodes_to_visit.pop(). Since it's a list, pop() removes the last element (which is the first element added, self).
After visiting the current node, its children are appended to nodes_to_visit. These children are added to the end of the list, effectively pushing them onto the stack.
"""

root = TreeNode("A")
child1 = TreeNode("C")
child2 = TreeNode("B")
root.add_child(child1)
root.add_child(child2)

#grandchild1 = TreeNode("D")
#grandchild2 = TreeNode("E")
#root.add_child(child1)
#root.add_child(child2)
#child1.add_child(grandchild1)
#child1.add_child(grandchild2)

root.traverse()

import matplotlib.pyplot as plt

def visualize_tree(node, x, y, level=0, spacing=10):
    plt.plot(x, y, 'o', color='black')
    plt.text(x, y, str(node.value), ha='center', va='center', fontsize=24)
    for i, child in enumerate(node.children):
        new_x = x + spacing * (i + 0.8)  # Adjust spacing for better layout
        new_y = y - level * spacing
        plt.plot([x, new_x], [y, new_y], 'b-')  # Draw connecting line
        visualize_tree(child, new_x, new_y, level + 1, spacing)

visualize_tree(root, 50, 50)
plt.axis('off')
plt.show()

"""Pre-order traversal might show nodes in a straight line, depending on the children order.

**Implementation of Depth tree Traversal**

Preorder traversal is a depth-first tree traversal algorithm. In depth-first traversal, we start at the root node and then we explore a branch of the tree till the end and then we backtrack and traverse another branch.
"""

class BinaryTreeNode:
  def __init__(self, data):
    self.data = data
    self.leftChild = None
    self.rightChild=None

def insert(root,newValue):
    #if binary search tree is empty, make a new node and declare it as root
    if root is None:
        root=BinaryTreeNode(newValue)
        return root
    #binary search tree is not empty, so we will insert it into the tree
    #if newValue is less than value of data in root, add it to left subtree and proceed recursively
    if newValue<root.data:
        root.leftChild=insert(root.leftChild,newValue)
    else:
        #if newValue is greater than value of data in root, add it to right subtree and proceed recursively
        root.rightChild=insert(root.rightChild,newValue)
    return root
def preorder(root):
    #if root is None return
        if root==None:
            return
        #traverse root
        print(root.data)
        #traverse left subtree
        preorder(root.leftChild)
        #traverse right subtree
        preorder(root.rightChild)
root= insert(None,15)
insert(root,10)
insert(root,25)
insert(root,6)
insert(root,14)
insert(root,20)
insert(root,60)
print("Printing values of binary tree in preorder Traversal.")
preorder(root)

"""The None keyword is used to define a null value, or no value at all.

None is not the same as 0, False, or an empty string. None is a data type of its own (NoneType) and only None can be None.

**None as Missing Child:**

In the TreeNode class, the children attribute is a list that stores references to child nodes.
If a node doesn't have any children, its children list will be empty.
In Python, an empty list is represented by [].

The insert function in  code for a binary search tree (BST) handles two cases when receiving the root node:

1. Empty Tree (root is None):

If the root is None, it signifies an empty tree.
In this case, the insert function creates a new node with the provided newValue and assigns it to the root.
Essentially, this new node becomes the first (and only) node in the tree.
The return root statement sends this newly created root node back to the caller.
2. Non-Empty Tree (root has a value):

If the root already has a value, the function needs to find the appropriate location for the new node based on its value (newValue) compared to the current node's data.
The function uses recursion to navigate the tree:
If newValue is less than the data in the current root, the function recursively calls insert on root.leftChild. This ensures nodes with smaller values are placed in the left subtree.
If newValue is greater than the data in the current root, the function recursively calls insert on root.rightChild. This ensures nodes with larger values go in the right subtree.

**implementation of Depth First Search**
"""

# Python program for postorder traversals

# Structure of a Binary Tree Node


class Node:
    def __init__(self, v):
        self.data = v
        self.left = None
        self.right = None

# Function to print postorder traversal


def printPostorder(node):
    if node == None:
        return

    # First recur on left subtree
    printPostorder(node.left)

    # Then recur on right subtree
    printPostorder(node.right)

    # Now deal with the node
    print(node.data, end=' ')


# Driver code
if __name__ == '__main__':
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.right.right = Node(6)

    # Function call
    print("Postorder traversal of binary tree is:")
    printPostorder(root)

class DirectedGraph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, start, end, cost):
        if start not in self.graph:
            self.graph[start] = []
        self.graph[start].append((end, cost))

    def get_neighbors(self, node):
        if node in self.graph:
            return self.graph[node]
        return []

# Example usage:
graph = DirectedGraph()
graph.add_edge('A', 'B', 4)
graph.add_edge('A', 'C', 2)
graph.add_edge('B', 'C', 5)
graph.add_edge('B', 'D', 10)
graph.add_edge('C', 'D', 3)
graph.add_edge('C', 'E', 8)
graph.add_edge('D', 'E', 6)

print("Neighbors of node 'A':", graph.get_neighbors('A'))
print("Neighbors of node 'B':", graph.get_neighbors('B'))

import networkx as nx
# Create a directed graph
G = nx.DiGraph()

# Add nodes and edges with costs
for start, edges in graph.graph.items():
    for edge in edges:
        end, cost = edge
        G.add_edge(start, end, weight=cost)

# Plot the graph
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_size=1000, node_color='skyblue', font_size=12, font_weight='bold', arrows=True)
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red')

"""**The primary goal of the uniform-cost search is to find a path to the goal node which has the lowest cumulative cost. Uniform-cost search expands nodes according to their path costs form the root node. It can be used to solve any graph/tree where the optimal cost is in demand. A uniform-cost search algorithm is implemented by the priority queue. It gives maximum priority to the lowest cumulative cost**"""

class Graph:
    def __init__(self):
        self.graph = OrderedDict()

    def add_node(self, node):
        self.graph[node] = list()

    def add_edge(self, node1, node2, label=None):
      self.graph[node1].append(node2)
      self.graph[node2].append(node1)
      #self.graph[node2] = list(self.graph[node2])



    def nodes(self):
        return list(self.graph.keys())

    def edges(self):
        return list(self.graph.values())

    def get_edge_label(self, node1, node2):
        return self.graph[node1][node2]

    def __str__(self):
        return str(self.graph)

"""This code defines a class DirectedGraph that represents a directed graph, which is a graph where edges have a direction and represent a one-way relationship between nodes. The class has three methods:
__init__: This is the constructor method, which is called when an object of the class is created. It initializes the graph by creating an empty dictionary self.graph.
add_edge: This method adds an edge to the graph. It takes three arguments: start, end, and cost. The start and end arguments represent the nodes that the edge connects, and the cost argument represents the weight or cost of the edge. If the start node is not already in the graph, it creates a new dictionary for it in self.graph. Then, it adds the end node to the dictionary of the start node, with the cost as its value.
get_neighbors: This method returns a dictionary of all the neighbors of a given node. It takes a single argument, node, which represents the node whose neighbors are to be found. If the node is in the graph, it returns a dictionary containing all the nodes that have an edge pointing to the node, with their corresponding edge weights. If the node is not in the graph, it returns an empty dictionary.

In summary, this code defines a basic directed graph class that allows adding edges and retrieving neighbors of a node. The graph is represented as a dictionary of dictionaries, where each inner dictionary represents a node and contains a list of its neighbors and their edge weights.
"""

class DirectedGraph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, start, end, cost):
        if start not in self.graph:
            self.graph[start] = {}
        self.graph[start][end] = cost

    def get_neighbors(self, node):
        if node in self.graph:
            return self.graph[node]
        return {}


# Example usage:
graph = DirectedGraph()
graph.add_edge('A', 'B', 4)
graph.add_edge('A', 'C', 2)
graph.add_edge('B', 'C', 5)
graph.add_edge('B', 'D', 10)
graph.add_edge('C', 'D', 3)
graph.add_edge('C', 'E', 8)
graph.add_edge('D', 'E', 6)

print("Neighbors of node 'A':", graph.get_neighbors('A'))
print("Neighbors of node 'B':", graph.get_neighbors('B'))

import matplotlib.pyplot as plt

class DirectedGraph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, start, end, cost):
        if start not in self.graph:
            self.graph[start] = {}
        self.graph[start][end] = cost

    def get_neighbors(self, node):
        if node in self.graph:
            return self.graph[node]
        return {}

    def plot_graph(self):
        plt.figure(figsize=(8, 6))
        for start in self.graph:
            plt.plot(start[0], start[1], 'bo')  # plot nodes
            for end in self.graph[start]:
                plt.arrow(start[0], start[1], end[0] - start[0], end[1] - start[1],
                          head_width=0.05, head_length=0.1, fc='blue', ec='blue')
                plt.text((start[0] + end[0]) / 2, (start[1] + end[1]) / 2, str(self.graph[start][end]),
                         fontsize=12, color='red')
        plt.xlim(0, 1)
        plt.ylim(0, 1)
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.title('Directed Graph with Costs')
        plt.grid(True)
        plt.show()

# Example usage:
graph = DirectedGraph()
graph.add_edge((0.1, 0.5), (0.3, 0.7), 4)
graph.add_edge((0.1, 0.5), (0.3, 0.3), 2)
graph.add_edge((0.3, 0.7), (0.5, 0.7), 5)
graph.add_edge((0.3, 0.7), (0.5, 0.5), 10)
graph.add_edge((0.3, 0.3), (0.5, 0.5), 3)
graph.add_edge((0.3, 0.3), (0.5, 0.1), 8)
graph.add_edge((0.5, 0.7), (0.7, 0.5), 6)

graph.plot_graph()

import matplotlib.pyplot as plt
import graphviz

edges=[]
dot = graphviz.Digraph()
dot.attr('node', shape='circle')
dot.node('root')
dot.node('1')
dot.node('2')
dot.node('3')
#dot.node('4','d')
edges.append(dot.edge('root', '1',edge_label='0'))
dot.edge('2', '3', constraint='True',label='1')

dot

edges = dot.edge

edges

import graphviz

dot = graphviz.Digraph()
dot.attr('node', shape='circle')
dot.node('root')
dot.node('1')
dot.node('2')
dot.node('3')
dot.edge('root', '1', xlabel='0')  # Specify the label directly within the label parameter
dot.edge('2', '3', constraint='True', xlabel='1')  # Specify the label directly within the label parameter

import pydot

graph = pydot.Dot("my_graph", graph_type="graph", bgcolor="yellow")

# Add nodes
my_node = pydot.Node("a")
graph.add_node(my_node)
# Or, without using an intermediate variable:
graph.add_node(pydot.Node("b", shape="circle"))

# Add edges
my_edge = pydot.Edge("a", "b",label=3, color="blue")
graph.add_edge(my_edge)
# Or, without using an intermediate variable:
graph.add_edge(pydot.Edge("b", "c", color="blue"))

graph

import networkx

my_networkx_graph = networkx.drawing.nx_pydot.from_pydot(graph)

my_networkx_graph

output_graphviz_svg = graph.create_svg()

graph.write_png("output1.png")

graph=[['S','A',6],
       ['S','B',5],
       ['S','C',10],
       ['A','E',6],
       ['B','E',6],
       ['B','D',7],
       ['C','D',6],
       ['E','F',6],
       ['D','F',6],
       ['F','G',1]]
temp = []
temp1 = []
for i in graph:
  temp.append(i[0])
  temp1.append(i[1])
nodes = set(temp).union(set(temp1))
def UCS(graph, costs, open, closed, cur_node):
  if cur_node in open:
    open.remove(cur_node)
  closed.add(cur_node) #In the CLOSED list, it places those nodes which have already expanded
  for i in graph:
    if(i[0] == cur_node and costs[i[0]]+i[2] < costs[i[1]]):
      open.add(i[1])
      costs[i[1]] = costs[i[0]]+i[2]
      path[i[1]] = path[i[0]] + ' -> ' + i[1]
  costs[cur_node] = 999999
  small = min(costs, key=costs.get)
  if small not in closed:
    UCS(graph, costs, open,closed, small)
costs = dict()
temp_cost = dict()
path = dict()
for i in nodes:
  costs[i] = 999999
  path[i] = ' '
open = set()
closed = set()
start_node = input("Enter the Start State: ")
open.add(start_node)  #it places nodes which have yet not been expanded.
path[start_node] = start_node
costs[start_node] = 0
UCS(graph, costs, open, closed, start_node)
goal_node = input("Enter the Goal State: ")
print("Path with least cost is: ",path[goal_node])

path

temp

temp1

nodes

for i in graph:
  print(i)



for u,v in enumerate(graph):
  print(v)

import matplotlib.pyplot as plt
for row in graph:
  for  element in row:
    print(element, end=' ')
  print()

"""A* SEARCH
Psuedocode available [A*search](https://mat.uab.cat/~alseda/MasterOpt/AStar-Algorithm.pdf)
"""

from matplotlib import pyplot as plt
import numpy as np
import matplotlib

from matplotlib import colormaps
list(colormaps)

class Node():
    """A node class for A* Pathfinding"""

    def __init__(self, parent=None, position=None):
        self.parent = parent
        self.position = position

        self.g = 0
        self.h = 0
        self.f = 0

    def __eq__(self, other):
        return self.position == other.position


def astar(maze, start, end):
    """Returns a list of tuples as a path from the given start to the given end in the given maze"""

    # Create start and end node
    start_node = Node(None, start)
    start_node.g = start_node.h = start_node.f = 0
    end_node = Node(None, end)
    end_node.g = end_node.h = end_node.f = 0

    # Initialize both open and closed list
    open_list = []
    closed_list = []

    # Add the start node
    open_list.append(start_node)

    # Loop until you find the end
    while len(open_list) > 0:

        # Get the current node
        current_node = open_list[0]
        current_index = 0
        for index, item in enumerate(open_list):
            if item.f < current_node.f:
                current_node = item
                current_index = index

        # Pop current off open list, add to closed list
        open_list.pop(current_index)
        closed_list.append(current_node)

        # Found the goal
        if current_node == end_node:
            path = []
            current = current_node
            while current is not None:
                path.append(current.position)
                current = current.parent
            return path[::-1] # Return reversed path

        # Generate children
        children = []
        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]: # Adjacent squares

            # Get node position
            node_position = (current_node.position[0] + new_position[0], current_node.position[1] + new_position[1])

            # Make sure within range
            if node_position[0] > (len(maze) - 1) or node_position[0] < 0 or node_position[1] > (len(maze[len(maze)-1]) -1) or node_position[1] < 0:
                continue

            # Make sure walkable terrain
            if maze[node_position[0]][node_position[1]] != 0:
                continue

            # Create new node
            new_node = Node(current_node, node_position)

            # Append
            children.append(new_node)

        # Loop through children
        for child in children:

            # Child is on the closed list
            for closed_child in closed_list:
                if child == closed_child:
                    continue

            # Create the f, g, and h values
            child.g = current_node.g + 1
            child.h = ((child.position[0] - end_node.position[0]) ** 2) + ((child.position[1] - end_node.position[1]) ** 2)
            child.f = child.g + child.h

            # Child is already in the open list
            for open_node in open_list:
                if child == open_node and child.g > open_node.g:
                    continue

            # Add the child to the open list
            open_list.append(child)


def main():

    maze = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
    m=np.asarray(maze)

    ij = np.argwhere(m ==1)
    #ax=plt.subplot()
    #c = '1' if (m[ij]==1)else 'o'
    #ax.text(ij[0],ij[1], c, va='center', ha='center')
    kh=np.argwhere(m==0)
    #print(kh)
#print(ij)
    #for x_val, y_val in zip(x.flatten(), y.flatten()):
    start = (0, 0)
    end = (7, 6)
    #print(m[7, 6])
    #print(m[0,0])
    # Find the indices of the cells that contain 0

# Assign green color to the start cell
    m[0,0] = 3

# Assign red color to the end cell
    m[7,6] =1
    fig, ax = plt.subplots()
# Using matshow here just because it sets the ticks up nicely. imshow is faster.
    ax.matshow(m)
    #ax.annotate(m.values,ij)
# Create a colormap for the cells
    cmap = plt.get_cmap('tab20c_r')

# Define the colors for the cells
    #colors = [cmap(2) for _ in range(256)]


# Create an image object
    img = ax.imshow(m, cmap=cmap)


# Set the title and labels
    plt.title('Maze')
    plt.xlabel('X')
    plt.ylabel('Y')

# Show the image
    plt.show()
    #matplotlib.pyplot.matshow(m, fignum=None,)
    path = astar(maze, start, end)
    print(path)


if __name__ == '__main__':
    main()

import numpy as np
main()

maze = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
m=np.asarray(maze)

fig, ax = plt.subplots()
# Using matshow here just because it sets the ticks up nicely. imshow is faster.
ax.matshow(m, cmap='seismic')

for (i, j), z in np.ndenumerate(m):
    ax.text(j, i, '{:0.1f}'.format(z), ha='center', va='center')

plt.show()

import numpy as np
import matplotlib.pyplot as plt

maze = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

m = np.asarray(maze)

# Create masked array
masked_m = np.ma.masked_where(m != 0, m)  # Masking non-zero values
masked_m1=np.ma.masked_where(m != 1, m)
# Set specific color for specific locations
masked_m.mask[0, 0] = 4  # Unmask (0, 0) location
masked_m1.mask[8,4]=6
#ij = np.argwhere(m ==1)
#
fig, ax = plt.subplots()
# Using matshow here just because it sets the ticks up nicely. imshow is faster.
ax.matshow(masked_m, cmap='seismic')

for (i, j), z in np.ndenumerate(m):
    ax.text(j, i, '{:0.1f}'.format(z), ha='center', va='center')

plt.show()

import numpy as np
import matplotlib.pyplot as plt

maze = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

m = np.asarray(maze)

# Create masked array for value 0
masked_m_0 = np.ma.masked_where(m != 0, m)

# Create masked array for value 1
masked_m_1 = np.ma.masked_where(m != 1, m)
masked_m_2 = np.ma.masked_where(m, m)
# Unmask specific locations for different masked arrays
masked_m_2.mask[0, 0] =1# True  # Location (0, 0) for value 0
masked_m_2.mask[8, 4] =2# True  # Location (8, 4) for value 1

# Plot masked arrays with different colormaps
fig, ax = plt.subplots()
ax.matshow(masked_m_0, cmap='Greens')  # Green colormap for value 0
ax.matshow(masked_m_1, cmap='Reds')   # Red colormap for value 1

# Annotate the values
for (i, j), z in np.ndenumerate(m):
    ax.text(j, i, '{:0.1f}'.format(z), ha='center', va='center')

plt.show()

import matplotlib.pyplot as plt
import numpy as np

#data = np.random.random((4, 4))
maze = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

m = np.asarray(maze)
m[0,0]=2
m[8,5]=3
fig, ax = plt.subplots()
# Using matshow here just because it sets the ticks up nicely. imshow is faster.
ax.matshow(m, cmap='seismic')

for (i, j), z in np.ndenumerate(m):
    ax.text(j, i, '{:0.1f}'.format(z), ha='center', va='center')

plt.show()

class Node():
    """A node class for A* Pathfinding"""

    def __init__(self, parent=None, position=None):
        self.parent = parent
        self.position = position

        self.g = 0
        self.h = 0
        self.f = 0

    def __eq__(self, other):
        return self.position == other.position


def astar(maze, start, end):
    """Returns a list of tuples as a path from the given start to the given end in the given maze"""

    # Create start and end node
    start_node = Node(None, start)
    start_node.g = start_node.h = start_node.f = 0
    end_node = Node(None, end)
    end_node.g = end_node.h = end_node.f = 0

    # Initialize both open and closed list
    open_list = []
    closed_list = []

    # Add the start node
    open_list.append(start_node)

    # Loop until you find the end
    while len(open_list) > 0:

        # Get the current node
        current_node = open_list[0]
        current_index = 0
        for index, item in enumerate(open_list):
            if item.f < current_node.f:
                current_node = item
                current_index = index

        # Pop current off open list, add to closed list
        open_list.pop(current_index)
        closed_list.append(current_node)

        # Found the goal
        if current_node == end_node:
            path = []
            current = current_node
            while current is not None:
                path.append(current.position)
                current = current.parent
            return path[::-1] # Return reversed path

        # Generate children
        children = []
        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]: # Adjacent squares

            # Get node position
            node_position = (current_node.position[0] + new_position[0], current_node.position[1] + new_position[1])

            # Make sure within range
            if node_position[0] > (len(maze) - 1) or node_position[0] < 0 or node_position[1] > (len(maze[len(maze)-1]) -1) or node_position[1] < 0:
                continue

            # Make sure walkable terrain
            if maze[node_position[0]][node_position[1]] != 0:
                continue

            # Create new node
            new_node = Node(current_node, node_position)

            # Append
            children.append(new_node)

        # Loop through children
        for child in children:

            # Child is on the closed list
            for closed_child in closed_list:
                if child == closed_child:
                    continue

            # Create the f, g, and h values
            child.g = current_node.g + 1
            child.h = ((child.position[0] - end_node.position[0]) ** 2) + ((child.position[1] - end_node.position[1]) ** 2)
            child.f = child.g + child.h

            # Child is already in the open list
            for open_node in open_list:
                if child == open_node and child.g > open_node.g:
                    continue

            # Add the child to the open list
            open_list.append(child)

start = (0, 0)
end = (7, 6)
path = astar(maze, start, end)
print(path)

class Node:
    """
    A node class for A* Pathfinding
    """

    def __init__(self, parent=None, position=None):
        self.parent = parent
        self.position = position

        self.g = 0
        self.h = 0
        self.f = 0

    def __eq__(self, other):
        return self.position == other.position


def return_path(current_node):
    path = []
    current = current_node
    while current is not None:
        path.append(current.position)
        current = current.parent
    return path[::-1]  # Return reversed path


def astar(maze, start, end, allow_diagonal_movement = False):
    """
    Returns a list of tuples as a path from the given start to the given end in the given maze
    :param maze:
    :param start:
    :param end:
    :param allow_diagonal_movement: do we allow diagonal steps in our path
    :return:
    """

    # Create start and end node
    start_node = Node(None, start)
    start_node.g = start_node.h = start_node.f = 0
    end_node = Node(None, end)
    end_node.g = end_node.h = end_node.f = 0

    # Initialize both open and closed list
    open_list = []
    closed_list = []

    # Add the start node
    open_list.append(start_node)

    # Adding a stop condition
    outer_iterations = 0
    max_iterations = (len(maze) // 2) ** 2

    # what squares do we search
    adjacent_squares = ((0, -1), (0, 1), (-1, 0), (1, 0),)
    if allow_diagonal_movement:
        adjacent_squares = ((0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1),)

    # Loop until you find the end
    while len(open_list) > 0:
        outer_iterations += 1

        # Get the current node
        current_node = open_list[0]
        current_index = 0
        for index, item in enumerate(open_list):
            if item.f < current_node.f:
                current_node = item
                current_index = index

        if outer_iterations > max_iterations:
            # if we hit this point return the path such as it is
            # it will not contain the destination
            warn("giving up on pathfinding too many iterations")
            return return_path(current_node)

        # Pop current off open list, add to closed list
        open_list.pop(current_index)
        closed_list.append(current_node)

        # Found the goal
        if current_node == end_node:
            return return_path(current_node)

        # Generate children
        children = []

        for new_position in adjacent_squares:  # Adjacent squares

            # Get node position
            node_position = (current_node.position[0] + new_position[0], current_node.position[1] + new_position[1])

            # Make sure within range
            within_range_criteria = [
                node_position[0] > (len(maze) - 1),
                node_position[0] < 0,
                node_position[1] > (len(maze[len(maze) - 1]) - 1),
                node_position[1] < 0,
            ]

            if any(within_range_criteria):
                continue

            # Make sure walkable terrain
            if maze[node_position[0]][node_position[1]] != 0:
                continue

            # Create new node
            new_node = Node(current_node, node_position)

            # Append
            children.append(new_node)

        # Loop through children
        for child in children:

            # Child is on the closed list
            if len([closed_child for closed_child in closed_list if closed_child == child]) > 0:
                continue

            # Create the f, g, and h values
            child.g = current_node.g + 1
            child.h = ((child.position[0] - end_node.position[0]) ** 2) + \
                      ((child.position[1] - end_node.position[1]) ** 2)
            child.f = child.g + child.h

            # Child is already in the open list
            if len([open_node for open_node in open_list if child == open_node and child.g > open_node.g]) > 0:
                continue

            # Add the child to the open list
            open_list.append(child)


def example():

    maze = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

    start = (0, 0)
    end = (7, 6)

path = astar(maze, start, end)
print(path)

def visualize_path(maze, path):
    """Visualizes the maze and the found path using matshow."""
    m = np.asarray(maze)

    # Assign distinct colors for start, end, path, and walls
    #m[0, 0] = 2  # Start
    m[path[-1][0], path[-1][1]] = 3  # End
    for cell in path:
        m[cell[0], cell[1]] = 1  # Path

    # Customize colormap for clarity
    cmap = plt.cm.get_cmap('viridis')


    fig, ax = plt.subplots()
    ax.matshow(m, cmap=cmap)
    for (i, j), z in np.ndenumerate(maze):
      ax.text(j, i, '{:0.1f}'.format(z), ha='center', va='center')

    # Remove unwanted ticks and axes
    ax.axis('off')

    plt.title("Maze with Search Path")
    plt.show()

visualize_path(maze, path)

import matplotlib.pyplot as plt
import numpy as np

# ... (Your A* implementation code as provided) ...

def visualize_path(maze, path):
    """Visualizes the maze and the found path using matshow."""
    m = np.asarray(path)
    for p in(len(m)):
      x,y=path[p]
      print(y)
    path_colors[path[-1][0], path[-1][1]] = 2  # End
    for cell in path:
        path_colors[cell[0], cell[1]] = 1  # Path

    # Normalize path_colors to align with viridis colormap (0-1 range)
   # path_colors = path_colors / path_colors.max()

    # Combine path colors with original maze values
    # Use original maze values for colors where path_colors is 0
    m = np.where(path_colors > 0, path_colors, m)

    # Customize colormap for clarity
    cmap = plt.cm.get_cmap('viridis')

    fig, ax = plt.subplots()
    ax.matshow(m, cmap=cmap)

    # Display original values for non-path cells
    for (i, j), z in np.ndenumerate(maze):
        if path_colors[i, j] == 0:
            ax.text(j, i, '{:0.1f}'.format(z), ha='center', va='center')

    # Remove unwanted ticks and axes
    ax.axis('off')

    plt.title("Maze with Search Path")
    plt.show()

visualize_path(maze, path)

p=np.array(path)
x,y=p[-1]

y

import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

min_val, max_val, diff = 0., 10., 1.

#imshow portion
#N_points = (max_val - min_val) / diff
#imshow_data = np.random.rand(N_points, N_points)
ax.imshow(m, interpolation='nearest')

#text portion
#ind_array = np.arange(min_val, max_val, diff)
x, y = np.meshgrid(m, path)


ax.grid()
plt.show()

fig, ax = plt.subplots()
# Using matshow here just because it sets the ticks up nicely. imshow is faster.
ax.matshow(m, cmap='seismic')


for (i, j), z in np.ndenumerate(m):

    ax.text(j, i, '{:0.1f}'.format(z), ha='center', va='center')

plt.show()

graph=[['S','A',6],
       ['S','B',5],
       ['S','C',10],
       ['A','E',6],
       ['B','E',6],
       ['B','D',7],
       ['C','D',6],
       ['E','F',6],
       ['D','F',6],
       ['F','G',1]]
temp = []
temp1 = []
cs=[]
for i in graph:
  temp.append(i[0])
  temp1.append(i[1])
  cs.append(i[2])
nodes = set(temp).union(set(temp1))
def UCS(graph, costs, open, closed, cur_node):
  if cur_node in open:
    open.remove(cur_node)
  closed.add(cur_node) #In the CLOSED list, it places those nodes which have already expanded
  for i in graph:
    if(i[0] == cur_node and costs[i[0]]+i[2] < costs[i[1]]):
      open.add(i[1])
      costs[i[1]] = costs[i[0]]+i[2]
      path[i[1]] = path[i[0]] + ' -> ' + i[1]
  costs[cur_node] = 999999
  small = min(costs, key=costs.get)
  if small not in closed:
    UCS(graph, costs, open,closed, small)
costs = dict()
temp_cost = dict()
path = dict()
for i in nodes:
  costs[i] = 999999
  path[i] = ' '
open = set()
closed = set()
start_node = input("Enter the Start State: ")
open.add(start_node)  #it places nodes which have yet not been expanded.
path[start_node] = start_node
costs[start_node] = 0
UCS(graph, costs, open, closed, start_node)
goal_node = input("Enter the Goal State: ")
print("Path with least cost is: ",path[goal_node])