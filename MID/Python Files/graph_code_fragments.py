# -*- coding: utf-8 -*-
"""Graph_Code_Fragments.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K8eZKubhrZCrXzH61bvjbOeVOFXqRXVM

The tutorial is based on a previous version of networkx where g.edges() or g.edges(Data=True) would give you a list of tuples. Lists are subscriptable.

The version you are running has a different output, g.edges gives you an EdgeView property, and g.edges(data=True) an EdgeDataView object which are not subscriptable.

list(g.edges(data=True))[0:5]
"""

import networkx as nx
import networkx.generators.small as gs
import matplotlib.pyplot as plt
data=[0.7]
G = nx.Graph()
G.add_nodes_from(range(0, 7))
#G.add_edges_from(1, 2, weight=1.0)
G.add_edge(2, 3, weight=1.0)
G.add_edge(3, 4, weight=2.0)
G.edges(data=True)
#g = gs.krackhardt_kite_graph()
nx.get_edge_attributes(G,'weight')
nx.draw (G,with_labels=True)

plt.savefig('tmp.png')

G = nx.Graph()
G.add_node('A')
G.add_node('B')
G.add_node('C')
G.add_node('D')
G.add_node('E')

node_pos = {'A':(1,2),'B':(2,3),'C':(2,1),'D':(3,1),'E':(4,3),'F':(5,1)} #From A we have 2 edges, from b we have 3 edges
#G.add_edges_from([('A', 'B'),('A','E'),('E','B'),('C','B'),('C','E'),('E','D'),('C','D')])
nx.draw(G,node_pos,font_color = 'white', node_shape = 's', with_labels = True,)
  #G.add_edges_from(values)

G = nx.Graph()
G.add_node('A')
G.add_node('B')
G.add_node('C')
G.add_node('D')
G.add_node('E')
G.add_node('F')

G.add_edge('A', 'B', weight=3)
G.add_edge('A', 'C', weight=2)
G.add_edge('B', 'C', weight=1)
G.add_edge('B', 'E', weight=3)
G.add_edge('C', 'D', weight=8)
G.add_edge('E', 'F', weight=4)
G.add_edge('D', 'F', weight=2)
G.add_edge('B', 'D', weight=4)
G.add_edge('E', 'D', weight=4)

#node_pos = {'A':(1,2),'B':(2,3),'C':(2,1),'D':(3,1),'E':(4,3),'F':(5,1)} #From A we have 2 edges, from b we have 3 edges

def show_wgraph(custom_node_positions=None):
    plt.figure()

    if custom_node_positions==None:
        pos = nx.spring_layout(G)
    else:
        pos=custom_node_positions

    weight_labels = nx.get_edge_attributes(G,'weight')
    nx.draw(G,pos,font_color = 'white', node_shape = 's', with_labels = True,)
    output = nx.draw_networkx_edge_labels(G,pos,edge_labels=weight_labels)

show_wgraph(node_pos)

G = nx.DiGraph()
G.add_edges_from([(1, 2, {'weight': 10}), (2, 3, {'weight': 0}), (2, 5, {'weight': 0}), (2, 6, {'weight': 0}), (2, 1, {'weight': 0}), (3, 4, {'weight': 10}), (3, 7, {'weight': 0}), (3, 8, {'weight': 0}), (3, 2, {'weight': 0}), (4, 3, {'weight': 0}), (5, 2, {'weight': 0}), (6, 2, {'weight': 0}), (7, 3, {'weight': 0}), (8, 3, {'weight': 0})])


# example edge set

edge_set = [(1, 2), (2, 3), (2, 5), (2, 6), (3, 8), (3, 4), (3, 7)]


# solution

T = G.edge_subgraph(edge_set).to_undirected()
T.edges(data = True)
nx.draw(T,with_labels=True)

import queue
from queue import PriorityQueue
class Node:
  def __init__(self, data,value,value2):
    self.left = None
    self.right = None
    self.data = data
    self.hn = value
    self.gn = value2
  def PrintTree(self):
    print( self.data)
    if self.left:
      self.left.PrintTree()
    if self.right:
      self.right.PrintTree()
def insert(p,root):
  p.put(self.data,rself.value)
  if self.left:
    self.left.PrintTree()
    if self.right:
      self.right.PrintTree()
  def check(self):
    found = False
    p = PriorityQueue()
    p.put((self.hn,self))
    while not found:
      k = p.get()
      n = k[1]
      print("\nSelected node : " + n.data + "\n")
      if( n.data == 'H' ):
        print("Found")
        found=True
        return True;
        if n.left:
          print("at " + n.left.data + " ,h(n) : "+ str(n.left.hn))
          p.put((n.left.hn,n.left))
          if n.right:
            print("at " + n.right. data + " ,h(n) : "+ str(n.right.hn))
            p.put((n.right.hn,n.right))

root = Node('S',13,0)
root.left = Node('A',12,3)
root.right = Node('B',4,2)
root.left.left = Node('C',7,4)
root.left.right = Node('D',3,1)
root.right.left = Node('E',8,3)
root.right.right = Node('F',2,1)
root.right.left.left = Node('H',4,5)
root.right.right.left = Node('I',9,2)
root.right.right.right = Node('G',0,3)

graph = {
'5': ['3','7'],
'3' : ['2','4'],
'7' : ['8'],
'2' : [],
'4' : ['8'],
'8' : []
}
visited = [] # List for visited nodes.
queue = [] #Initialize a queue
def bfs(visited, graph, node):
  visited.append(node)
  queue.append(node)
  while queue:
    m = queue.pop(0)
    print (m, end ="")
    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
        print("quot;Following is the Breadth-First Search")
        bfs(visited, graph,'5')

graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}

visited = set() # Set to keep track of visited nodes of graph.

def s(visited, graph, node):  #function for dfs
    if node not in visited:
        print (node)
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)

# Driver Code
print("Following is the Depth-First Search")
s(visited, graph, '5')

import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

# Build a dataframe with your connections
df = pd.DataFrame({ 'from':['A', 'B', 'C','A','E','F','E','G','G','D','F'], 'to':['D', 'A', 'E','C','A','F','G','D','B','G','C']})
df

# Build your graph
G=nx.from_pandas_edgelist(df, 'from', 'to')

# Fruchterman Reingold
nx.draw(G, with_labels=True, node_size=1500, node_color="skyblue", pos=nx.fruchterman_reingold_layout(G))
plt.title("fruchterman_reingold")
plt.show()

