# -*- coding: utf-8 -*-
"""Q3_Uniformed_Search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t-ccMxA534cjNK9X-JNR4GbgqKYZ7nqV
"""

from collections import defaultdict

class Graph:
    def __init__(self, graph=None):
        if graph is None:
            graph = defaultdict(list)
        self.graph = graph

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def dfs_util(self, v, visited):
        visited.add(v)
        print(v, end=' ')

        for neighbour in self.graph[v]:
            if neighbour not in visited:
                self.dfs_util(neighbour, visited)

    def dfs(self, start):
        visited = set()
        self.dfs_util(start, visited)

    def bfs(self, start):
        visited = set()
        queue = []
        queue.append(start)
        visited.add(start)

        while queue:
            vertex = queue.pop(0)
            print(vertex, end=' ')

            for neighbour in self.graph[vertex]:
                if neighbour not in visited:
                    queue.append(neighbour)
                    visited.add(neighbour)


adj_list = {
    0: [1, 2],
    1: [2],
    2: [0, 3],
    3: [3]
}

g = Graph(adj_list)

print("DFS Traversal:")
g.dfs(2)  # Start DFS from node 2
print("\nBFS Traversal:")
g.bfs(2)  # Start BFS from node 2

class Node:
    def __init__(self, key):
        self.data = key
        self.left = None
        self.right = None

def printOrder(root):
    if root is None:
        return

    # BFS implementation
    def bfs(root):
        queue = [root]
        while queue:
            node = queue.pop(0)
            print(node.data, end=' ')
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

    # DFS implementation
    def dfs(node):
        if node is None:
            return
        print(node.data, end=' ')
        dfs(node.left)
        dfs(node.right)

    # Printing BFS
    print("Breadth First Search (BFS):")
    bfs(root)
    print()

    # Printing DFS
    print("Depth First Search (DFS):")
    dfs(root)
    print()

# Binary Tree
root = Node('S')
root.left = Node('A')
root.right = Node('B')
root.left.left = Node('C')
root.left.right = Node('D')
root.right.left = Node('Z')
root.right.right = Node('K')
root.left.left.left = Node('M')
root.left.left.right = Node('O')
root.right.left.right = Node('G')
root.right.left.right.left = Node('H')

printOrder(root)

def ucs(goals, start):
    visited = set()
    queue = [(0, start)]

    while queue:
        current_cost, node = min(queue)
        queue.remove((current_cost, node))

        if node in visited:
            continue

        visited.add(node)

        if node in goals:
            return current_cost

        for neighbor in graph[node]:
            if neighbor not in visited:
                queue.append((current_cost + cost[(node, neighbor)], neighbor))

    return -1

# Creating graph
graph, cost = [[] for _ in range(8)], {}
# Adding edges in graph
graph[0].extend([1, 3])
graph[3].extend([1, 6, 4])
graph[1].append(6)
graph[4].extend([2, 5])
graph[2].append(1)
graph[5].extend([2, 6])
graph[6].append(4)
# Adding  cost
cost[(0, 1)] = 2
cost[(0, 3)] = 5
cost[(1, 6)] = 1
cost[(3, 1)] = 5
cost[(3, 6)] = 6
cost[(3, 4)] = 2
cost[(2, 1)] = 4
cost[(4, 2)] = 4
cost[(4, 5)] = 3
cost[(5, 2)] = 6
cost[(5, 6)] = 3
cost[(6, 4)] = 7
# Goal state
goal = [6]

answer = ucs(goal, 0)

print("Minimum cost from 0 to 6 is =", answer)

from collections import defaultdict

class Graph:
    def __init__(self, vertices):
        # No. of vertices
        self.V = vertices
        # default dictionary to store graph
        self.graph = defaultdict(list)

    # function to add an edge to graph
    def addEdge(self, u, v):
        self.graph[u].append(v)

    # A function to perform a Depth-Limited search from given source 'src'
    def DLS(self, src, target, maxDepth):
        if src == target:
            return True
        if maxDepth <= 0:
            return False
        for neighbor in self.graph[src]:
            if self.DLS(neighbor, target, maxDepth - 1):
                return True
        return False

    # IDDFS to search if the target is reachable from v.
    # It uses recursive DLS()
    def IDDFS(self, src, target, maxDepth):
        for depth in range(maxDepth + 1):
            if self.DLS(src, target, depth):
                return True
        return False

# Create a graph given in the above diagram
g = Graph(7)
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 3)
g.addEdge(1, 4)
g.addEdge(2, 5)
g.addEdge(2, 6)
target = 6
maxDepth = 3
src = 0

if g.IDDFS(src, target, maxDepth):
    print("Target is reachable from source within max depth")
else:
    print("Target is NOT reachable from source within max depth")

class AdjacentNode:
    def __init__(self, vertex):
        self.vertex = vertex
        self.next = None

# BidirectionalSearch implementation
class BidirectionalSearch:
    def __init__(self, vertices):
        # Initialize vertices and graph with vertices
        self.vertices = vertices
        self.graph = [None] * self.vertices
        # Initializing queue for forward and backward search
        self.src_queue = list()
        self.dest_queue = list()
        # Initializing source and destination visited nodes as False
        self.src_visited = [False] * self.vertices
        self.dest_visited = [False] * self.vertices
        # Initializing source and destination parent nodes
        self.src_parent = [None] * self.vertices
        self.dest_parent = [None] * self.vertices

    # Function for adding undirected edge
    def add_edge(self, src, dest):
        # Add edges to graph
        # Add source to destination
        node = AdjacentNode(dest)
        node.next = self.graph[src]
        self.graph[src] = node
        # Since graph is undirected add destination to source
        node = AdjacentNode(src)
        node.next = self.graph[dest]
        self.graph[dest] = node

    # Function for BFS
    def bfs(self, direction='forward'):
        if direction == 'forward':
            # BFS in forward direction
            current = self.src_queue.pop(0)
            connected_node = self.graph[current]
            while connected_node:
                vertex = connected_node.vertex
                if not self.src_visited[vertex]:
                    self.src_queue.append(vertex)
                    self.src_visited[vertex] = True
                    self.src_parent[vertex] = current
                connected_node = connected_node.next
        else:
            # BFS in backward direction
            current = self.dest_queue.pop(0)
            connected_node = self.graph[current]
            while connected_node:
                vertex = connected_node.vertex
                if not self.dest_visited[vertex]:
                    self.dest_queue.append(vertex)
                    self.dest_visited[vertex] = True
                    self.dest_parent[vertex] = current
                connected_node = connected_node.next

    # Check for intersecting vertex
    def is_intersecting(self):
        # Returns intersecting node if present else -1
        for i in range(self.vertices):
            if self.src_visited[i] and self.dest_visited[i]:
                return i
        return -1

    # Print the path from source to target
    def print_path(self, intersecting_node, src, dest):
        # Print final path from source to destination
        path = list()
        path.append(intersecting_node)
        i = intersecting_node
        while i != src:
            path.append(self.src_parent[i])
            i = self.src_parent[i]
        path = path[::-1]
        i = intersecting_node
        while i != dest:
            path.append(self.dest_parent[i])
            i = self.dest_parent[i]
        print("-----Path----")
        path = list(map(str, path))
        print(' '.join(path))

    # Function for bidirectional searching
    def bidirectional_search(self, src, dest):
        self.src_queue.append(src)
        self.src_visited[src] = True
        self.src_parent[src] = None

        self.dest_queue.append(dest)
        self.dest_visited[dest] = True
        self.dest_parent[dest] = None

        while self.src_queue and self.dest_queue:
            self.bfs('forward')
            self.bfs('backward')

            intersecting_node = self.is_intersecting()
            if intersecting_node != -1:
                print(f"Intersection at node {intersecting_node}")
                self.print_path(intersecting_node, src, dest)
                return True
        return -1

# N0. of Vertices in graph
n = 15
src = 0
dest = 14

graph = BidirectionalSearch(n)
graph.add_edge(0, 4)
graph.add_edge(1, 4)
graph.add_edge(2, 5)

out = graph.bidirectional_search(src, dest)
if out == -1:
    print(f"Path does not exist between {src} and {dest}")